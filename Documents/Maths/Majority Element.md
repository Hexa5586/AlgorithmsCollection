# 多数元素 - Boyer-Moore 投票算法

#数学

## 题目描述

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数**大于** $\lfloor \frac{n}{2} \rfloor$ 的元素。假设多数元素总是存在。

---
## 思路

* **Boyer Moore 算法**

我们将数组中的元素进行一种名为 **”抵消与联合“** 的操作：从数组中找到两个**不相等**的数字，并将两者**一起移出数组**。

假设我们**已知多数元素是谁**——假设为 $a$. 假设其出现次数为 $N_a$ ，其他元素的出现次数为 $N_{other}$ . 由于
$$N_a > \lfloor \frac{n}{2} \rfloor$$
于是由
$$N_{other} = n - N_a < n - \lfloor \frac{n}{2} \rfloor < N_a$$
假如其他元素合力与多数元素”作战“，全部用于”抵消“多数元素，也最多只能抵消掉 $n - N_a$ 个元素，而即使这样仍然有 $a$ 剩余。因此按照这样的抵消逻辑**无论如何进行抵消，最后留下的元素必然是多数元素** $a$ .

---
## 步骤

由于直接从数组中取数并抵消具有随机性，因此我们使用一种名为 **“攻占领地”** 的逻辑来进行这整个过程（我们假设**一个领地内不允许有任何敌对势力**）。所有人按顺序走向擂台，进行下列流程：

* 领地内有人？
	* 领地内的是**友军**？
		* 加入友军 **（联合）**
	* 领地内的是**敌军**？
		* 与一个敌军同归于尽 **（抵消）**
* 擂台上没有人？
	* 拔下城池上敌军的旗帜，插上本军的旗帜 **（更新）**

根据前面的证明，最后占领领地的团体一定是多数元素的“军队”。

```C++
int MajorityElement(const std::vector<int>& nums) {
	int candidate = nums[0], count = 1, nums_size = nums.size();
	
	for (int i = 1; i < nums_size; ++i) {
		if (count == 0) {
			candidate = nums[i];
		}
		count += (candidate == nums[i] ? 1 : -1);
	}
	return candidate;
}
```

上述代码中，`candidate` 可以视作“城池上的旗帜”，而 `count` 则是当前”领地“内”军队的人数“。

---
*具体代码见 Algorithms/MajorityElement.cpp.*